#!/usr/bin/env bash

# Abinstall WayBang installer
# Modified by Mr Green mrgreen(at)archbang(dot)org
# based on lilo fifo...scripts

#-------------------------------------------------------------------------------
# Created by helmuthdu mailto: helmuthdu[at]gmail[dot]com
# Contribution: flexiondotorg
#-------------------------------------------------------------------------------

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#-------------------------------------------------------------------------------

log_file=""

while [[ $# -gt 0 ]]; do
  case "$1" in
    -l|--log)
      timestamp=$(date +%F_%T | tr ':' '-')
      log_file="/tmp/abinstall_${timestamp}.log"
      shift
      ;;
    *)
      break
      ;;
  esac
done

# Redirect all output to log if set
if [[ -n "$log_file" ]]; then
  exec > >(tee -a "$log_file") 2>&1
  echo "Logging to $log_file"
fi

# --- Parse simple key=value or -i flags ---
for arg in "$@"; do
  case $arg in
    -i|--install) INTERACTIVE=0 ;;
    hostname=*)   host_name="${arg#*=}" ;;
    locale=*)     LOCALE_VALUE="${arg#*=}" ;;
    keymap=*)     KEYMAP_VALUE="${arg#*=}" ;;
  esac
done


#GLOBAL VARIABLES {{{
  checklist=( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 )
  # COLORS {{{
    Bold=$(tput bold)
    Underline=$(tput sgr 0 1)
    Reset=$(tput sgr0)
    # Regular Colors
    Red=$(tput setaf 1)
    Green=$(tput setaf 2)
    Yellow=$(tput setaf 3)
    Blue=$(tput setaf 4)
    Purple=$(tput setaf 5)
    Cyan=$(tput setaf 6)
    White=$(tput setaf 7)
    # Bold
    BRed=${Bold}$(tput setaf 1)
    BGreen=${Bold}$(tput setaf 2)
    BYellow=${Bold}$(tput setaf 3)
    BBlue=${Bold}$(tput setaf 4)
    BPurple=${Bold}$(tput setaf 5)
    BCyan=${Bold}$(tput setaf 6)
    BWhite=${Bold}$(tput setaf 7)
  #}}}
  # PROMPT {{{
    prompt1="Enter your option: "
    prompt2="Enter number of options (ex: 1 2 3 or 1-3): "
    prompt3="You have to manually enter the following commands, then press ${BYellow}ctrl+d${Reset} or type ${BYellow}exit${Reset}:"
  #}}}
  # EDITOR {{{
    EDITOR="vim"
  #}}}
  # MOUNTPOINTS {{{
    EFI_MOUNTPOINT="/boot/efi"
    ROOT_MOUNTPOINT="/dev/sda1"
    BOOT_MOUNTPOINT="/dev/sda"
    MNT="/mnt"
  # MIRRORLIST
    MIRROR=${MNT}/etc/pacman.d/mirrorlist
  #}}}
  ARCHI=$(uname -m)
  UEFI=0
  LVM=0
  LUKS=0
  LUKS_DISK="sda2"
  LUKS_NAME="cryptroot"
  VG_NAME="lvm"
  LV_ROOT="root"
  LIVE_USER="wblive"
  [[ $1 == -v || $1 == --verbose ]] && VERBOSE_MODE=1 || VERBOSE_MODE=0 # VERBOSE MODE
  [[ -f $LOG ]] && rm -f $LOG
  SPIN="/-\|" #SPINNER POSITION
  AUTOMATIC_MODE=0
  TRIM=0
  cpu_id=""
  # --- Optional installer variables (can be overridden by args) ---
  host_name=""          # For hostname
  LOCALE_VALUE=""       # For locale
  KEYMAP_VALUE=""       # For keyboard layout
  INTERACTIVE=1         # 1 = ask, 0 = skip prompts

#}}}
#COMMON FUNCTIONS {{{
  error_msg() { #{{{
    local _msg="${1}"
    echo -e "${_msg}"
    exit 1
  } #}}}
  cecho() { #{{{
    echo -e "$1"
    echo -e "$1" >>"$LOG"
    tput sgr0;
  } #}}}
  ncecho() { #{{{
    echo -ne "$1"
    echo -ne "$1" >>"$LOG"
    tput sgr0
  } #}}}
  spinny() { #{{{
    echo -ne "\b${SPIN:i++%${#SPIN}:1}"
  } #}}}
  progress() { #{{{
    ncecho "  ";
    while true; do
      kill -0 $pid &> /dev/null;
      if [[ $? == 0 ]]; then
        spinny
        sleep 0.25
      else
        ncecho "\b\b";
        wait $pid
        retcode=$?
        echo -ne "$pid's retcode: $retcode" >> $LOG
        if [[ $retcode == 0 ]] || [[ $retcode == 255 ]]; then
          cecho success
        else
          cecho failed
          echo -e "$PKG" >> $PKG_FAIL
          tail -n 15 $LOG
        fi
        break
      fi
    done
  } #}}}
  check_boot_system() { #{{{
    if [[ "$(cat /sys/class/dmi/id/sys_vendor)" == 'Apple Inc.' ]] || [[ "$(cat /sys/class/dmi/id/sys_vendor)" == 'Apple Computer, Inc.' ]]; then
      modprobe -r -q efivars || true  # if MAC
    else
      modprobe -q efivarfs            # all others
    fi
    if [[ -d "/sys/firmware/efi/" ]]; then
      ## Mount efivarfs if it is not already mounted
      if [[ -z $(mount | grep /sys/firmware/efi/efivars) ]]; then
        mount -t efivarfs efivarfs /sys/firmware/efi/efivars
      fi
      UEFI=1
      echo "UEFI Mode detected"
    else
      UEFI=0
      echo "BIOS Mode detected"
    fi
  }
  #}}}
   check_trim() { #{{{
    # Check if any block device supports TRIM/discard
    TRIM=0
    for device in /sys/block/*/queue/discard_granularity; do
      if [[ -f "$device" ]]; then
        discard_value=$(cat "$device" 2>/dev/null)
        if [[ "$discard_value" -gt 0 ]]; then
          TRIM=1
          break
        fi
      fi
    done
  }
   #}}}
   detect_cpu() { #{{{
    if grep -q "GenuineIntel" /proc/cpuinfo; then
      cpu_id="intel"
    elif grep -q "AuthenticAMD" /proc/cpuinfo; then
      cpu_id="amd"
    else
      cpu_id=""
    fi
  }
  #}}}
  check_root() { #{{{
    if [[ "$(id -u)" != "0" ]]; then
      error_msg "ERROR! You must execute the script as the 'root' user."
    fi
  } #}}}
  check_user() { #{{{
    if [[ "$(id -u)" == "0" ]]; then
      error_msg "ERROR! You must execute the script as a normal user."
    fi
  } #}}}
  check_hostname() { #{{{
    if [[ `echo ${HOSTNAME} | sed 's/ //g'` == "" ]]; then
      error_msg "ERROR! Hostname is not configured."
    fi
  } #}}}
  check_archiso() { #{{{
    if [[ ! -d "/run/archiso/airootfs" ]]; then
      error_msg "ERROR! Not running from WayBang live environment"
    fi
  } #}}}
  read_input() { #{{{
    if [[ $AUTOMATIC_MODE -eq 1 ]]; then
      OPTION=$1
    else
      read -p "$prompt1" OPTION
    fi
  } #}}}
  read_input_text() { #{{{
    if [[ $AUTOMATIC_MODE -eq 1 ]]; then
      OPTION=$2
    else
      read -p "$1 [y/N]: " OPTION
      echo ""
    fi
    OPTION=`echo "$OPTION" | tr '[:upper:]' '[:lower:]'`
  } #}}}
  read_input_options() { #{{{
    local line
    local packages
    if [[ $AUTOMATIC_MODE -eq 1 ]]; then
      array=("$1")
    else
      read -p "$prompt2" OPTION
      array=("$OPTION")
    fi
    for line in ${array[@]/,/ }; do
      if [[ ${line/-/} != $line ]]; then
        for ((i=${line%-*}; i<=${line#*-}; i++)); do
          packages+=($i);
        done
      else
        packages+=($line)
      fi
    done
    OPTIONS=("${packages[@]}")
  } #}}}
  print_line() { #{{{
    printf "%$(tput cols)s\n"|tr ' ' '-'
  } #}}}
  print_title() { #{{{
    clear
    print_line
    echo -e "# ${Bold}$1${Reset}"
    print_line
    echo ""
  } #}}}
  print_info() { #{{{
    #Console width number
    T_COLS=`tput cols`
    echo -e "${Bold}$1${Reset}\n" | fold -sw $(( $T_COLS - 18 )) | sed 's/^/\t/'
  } #}}}
  print_success() { #{{{
    #Console width number
    T_COLS=`tput cols`
    echo -e "${Bold}$1${Reset}\n" | fold -sw $(( $T_COLS - 18 )) | sed 's/^/\t/'
  } #}}}

  print_warning() { #{{{
    T_COLS=`tput cols`
    echo -e "${BYellow}$1${Reset}\n" | fold -sw $(( $T_COLS - 1 ))
  } #}}}
  print_danger() { #{{{
    T_COLS=`tput cols`
    echo -e "${BRed}$1${Reset}\n" | fold -sw $(( $T_COLS - 1 ))
  } #}}}
  add_line() { #{{{
    local _add_line=${1}
    local _filepath=${2}

    local _has_line=`grep -ci "${_add_line}" ${_filepath}`
    [[ $_has_line -eq 0 ]] && echo "${_add_line}" >> ${_filepath}
  } #}}}
  replace_line() { #{{{
    local _search=${1}
    local _replace=${2}
    local _filepath=${3}
    local _filebase=`basename ${3}`

    sed -e "s/${_search}/${_replace}/" ${_filepath} > /tmp/${_filebase} 2>"$LOG"
    if [[ ${?} -eq 0 ]]; then
      mv /tmp/${_filebase} ${_filepath}
    else
      cecho "failed: ${_search} - ${_filepath}"
    fi
  } #}}}
  checkbox() { #{{{
    #display [X] or [ ]
    [[ "$1" -eq 1 ]] && echo -e "${BBlue}[${Reset}${Bold}X${BBlue}]${Reset}" || echo -e "${BBlue}[ ${BBlue}]${Reset}";
  } #}}}
  checkbox_package() { #{{{
    #check if [X] or [ ]
    is_package_installed "$1" && checkbox 1 || checkbox 0
  } #}}}
  contains_element() { #{{{
    #check if an element exist in a string
    for e in "${@:2}"; do [[ $e == $1 ]] && break; done;
  } #}}}
  invalid_option() { #{{{
    print_line
    echo "Invalid option. Try another one."
    pause_function
  } #}}}
  pause_function() { #{{{
    print_line
    if [[ $AUTOMATIC_MODE -eq 0 ]]; then
      read -e -sn 1 -p "Press enter to continue..."
    fi
  } #}}}
  menu_item() { #{{{
    #check if the number of arguments is less then 2
    [[ $# -lt 2 ]] && _package_name="$1" || _package_name="$2";
    #list of chars to remove from the package name
    local _chars=("Ttf-" "-bzr" "-hg" "-svn" "-git" "-stable" "-icon-theme" "Gnome-shell-theme-" "Gnome-shell-extension-");
    #remove chars from package name
    for char in ${_chars[@]}; do _package_name=`echo ${_package_name^} | sed 's/'$char'//'`; done
    #display checkbox and package name
    echo -e "$(checkbox_package "$1") ${Bold}${_package_name}${Reset}"
  } #}}}
  mainmenu_item() { #{{{
    echo -e "$(checkbox "$1") ${Bold}$2${Reset}"
  } #}}}
  elihw() { #{{{
    [[ $OPT == b || $OPT == d ]] && break;
  } #}}}
  arch_chroot() { #{{{
    arch-chroot $MNT /bin/bash -c "${1}"
  }
  #}}}
  getkeymap() { #{{{
    local _keymaps=($(localectl list-keymaps))
    PS3="(shift+pgup/pgdown) $prompt1"
    echo "Select keymap:"
    select KEYMAP in "${_keymaps[@]}"; do
      if contains_element "$KEYMAP" "${_keymaps[@]}"; then
        break
      else
        invalid_option
      fi
    done
  }
  #}}}

 getxkeymap() { #{{{
    local _xkeymaps=($(localectl list-x11-keymap-layouts))
    PS3="(shift+pgup/pgdown) $prompt1"
    echo "Select keymap:"
    select XKEYMAP in "${_xkeymaps[@]}"; do
      if contains_element "$XKEYMAP" "${_xkeymaps[@]}"; then
        break
      else
        invalid_option
      fi
    done
  }

getmirror() {
  declare -a location
  input="${MIRROR}"
  while IFS= read -r line
  do
   # do stuff
   [[ $line =~ ^##.* ]] && location+=("${line//##}")

  done < "$input"

  PS3="(shift+pgup/pgdown) $prompt1"
  echo "Select location:"
  select LOCATION in "${location[@]}"; do
  if contains_element "$LOCATION" "${location[@]}"; then
        break
      else
        invalid_option
      fi
  done
  }

configure_mirrors() {
  # Create a mirrorlist based on location, may not be fastest servers but nearest..
  # Backup list
  #  cp ${MIRROR} ${MNT}/etc/pacman.d/mirrorlist.backup

  print_title "Configuring mirrors..."
  print_info "Select location"
  # Remove everything before Albania
  sed -i '1,/^## Albania/{/^## Albania/!d}' ${MIRROR} 

  OPTION=n
  while [[ $OPTION != y ]]; do
    getmirror
    echo ""
    read_input_text "Confirm Location: $LOCATION"
  done

  # magic happens here....
  sed -i -n -r "/${LOCATION}/,/^\s*$/p" ${MIRROR}

  }

  setlocale() { #{{{
    local _locale_list=(`cat /etc/locale.gen | grep UTF-8 | sed 's/\..*$//' | sed '/@/d' | awk '{print $1}' | uniq | sed 's/#//g'`);
    PS3="$prompt1"
    echo "Select locale:"
    select LOCALE in "${_locale_list[@]}"; do
      if contains_element "$LOCALE" "${_locale_list[@]}"; then
        LOCALE_UTF8="${LOCALE}.UTF-8"
        break
      else
        invalid_option
      fi
    done
  }
  #}}}
  settimezone() { #{{{
    local _zones=($(timedatectl list-timezones | sed 's/\/.*$//' | uniq))
    PS3="$prompt1"
    echo "Select zone:"
    select ZONE in "${_zones[@]}"; do
      if contains_element "$ZONE" "${_zones[@]}"; then
        local _subzones=($(timedatectl list-timezones | grep ${ZONE} | sed 's/^.*\///'))
        PS3="$prompt1"
        echo "Select subzone:"
        select SUBZONE in "${_subzones[@]}"; do
          if contains_element "$SUBZONE" "${_subzones[@]}"; then
            break
          else
            invalid_option
          fi
        done
        break
      else
        invalid_option
      fi
    done
  } #}}}
#}}}

WIKI="https://wiki.archlinux.org/index.php"

#ARCHLINUX INSTALL SCRIPTS MODE {{{
#SELECT KEYMAP {{{
select_xkeymap(){
  print_title "LABWC DESKTOP KEYBOARD LAYOUT"
  print_info "Setting keyboard layout for labwc compositor"
  OPTION=n
  while [[ $OPTION != y ]]; do
    getxkeymap
    read_input_text "Confirm keymap: $XKEYMAP"
  done
# Desktop keymap for labwc
# change in labwc/environment
   sed -i "s/XKB_DEFAULT_LAYOUT=.*/XKB_DEFAULT_LAYOUT=${XKEYMAP}/g" $MNT/home/${LIVE_USER}/.config/labwc/environment
}
#}}}

#UMOUNT PARTITIONS {{{
umount_partitions(){
  mounted_partitions=(`lsblk | grep ${MNT} | awk '{print $7}' | sort -r`)
  swapoff -a
  for i in ${mounted_partitions[@]}; do
    umount $i
  done
}
#}}}
#SELECT DEVICE {{{
select_device(){
  devices_list=(`lsblk -d | awk '{print "/dev/" $1}' | grep 'mmc\|nvme\|sd\|hd\|vd'`);
  PS3="$prompt1"
  echo -e "Select partition:\n"
  select device in "${devices_list[@]}"; do
    if contains_element "${device}" "${devices_list[@]}"; then
      break
    else
      invalid_option
    fi
  done
  BOOT_MNT=$device
}
#}}}
#CREATE PARTITION SCHEME {{{
create_partition_scheme(){
  LUKS=0
  LVM=0
  print_title "PARTITION DRIVE - ${WIKI}/Partitioning"
  print_info "Partitioning a hard drive allows one to logically divide the available space into sections that can be accessed independently of one another."
  print_warning "Maintain Current does not work with LUKS"
  partition_layout=("Default" "LVM" "LVM+LUKS" "Maintain Current")
  PS3="$prompt1"
  echo -e "Select partition scheme:"
  select OPT in "${partition_layout[@]}"; do
    case "$REPLY" in
      1)
        create_partition
        ;;
      2)
        create_partition
        setup_lvm
        ;;
      3)
        create_partition
        setup_luks
        setup_lvm
        ;;
      4)
        modprobe dm-mod
        vgscan &> /dev/null
        vgchange -ay &> /dev/null
        ;;
      *)
        invalid_option
        ;;
    esac
    [[ -n $OPT ]] && break
  done
}
#}}}
#SETUP PARTITION{{{
create_partition() {
  apps_list=("gparted" "cfdisk" "cgdisk" "fdisk" "gdisk" "parted")
  PS3="$prompt1"
  echo -e "Select partition program:"
  select OPT in "${apps_list[@]}"; do
    if contains_element "$OPT" "${apps_list[@]}"; then
      select_device

      case "$OPT" in
        gparted)
          gparted
          ;;
        parted)
          parted -a opt "${device}"
          ;;
        *)
          $OPT "${device}"
          ;;
      esac

      echo "Press ENTER to return to installer..."
      read
      break
    else
      invalid_option
    fi
  done
}
#}}}
#SETUP LUKS {{{
setup_luks() {
  print_title "LUKS - ${WIKI}/LUKS"
  print_info "The Linux Unified Key Setup (LUKS) provides full-disk encryption for Linux."
  print_danger "\tDo not use this for /boot or EFI partitions."

  # list available partitions, skipping EFI/boot and existing mapper devices
  block_list=($(lsblk -nrpo NAME,TYPE,MOUNTPOINT | awk '$2=="part" && $3=="" {print $1}'))
  PS3="$prompt1"
  echo -e "Select partition to encrypt with LUKS:"
  select OPT in "${block_list[@]}" "Cancel"; do
    if contains_element "$OPT" "${block_list[@]}"; then
      # confirm not encrypting /boot or EFI accidentally
      if [[ "$OPT" =~ .*1$ ]] && blkid "$OPT" | grep -q "vfat"; then
        print_error "$OPT appears to be EFI or /boot; skipping."
        return 1
      fi

      print_info "Setting up LUKS on $OPT ..."
      cryptsetup --cipher aes-xts-plain64 --key-size 512 --hash sha512 \
                 --iter-time 5000 --verify-passphrase luksFormat "$OPT" || return 1

      print_info "Opening LUKS container..."
      if [[ $TRIM -eq 1 ]]; then
        cryptsetup open --type luks --allow-discards "$OPT" "${LUKS_NAME}"
      else
        cryptsetup open --type luks "$OPT" "${LUKS_NAME}"
      fi

      # mark LUKS enabled and record device info
      LUKS=1
      LUKS_PART="$OPT"
      LUKS_MAPPER="/dev/mapper/${LUKS_NAME}"
      export LUKS LUKS_NAME LUKS_PART LUKS_MAPPER

      print_success "LUKS container created at ${LUKS_MAPPER}"
      break

    elif [[ "$OPT" == "Cancel" ]]; then
      print_warning "LUKS setup cancelled."
      return 1
    else
      invalid_option
    fi
  done
}

#}}}
#SETUP LVM {{{
setup_lvm() {
  print_title "LVM - ${WIKI}/LVM"
  print_info "LVM manages logical volumes inside your selected device."
  print_warning "Last logical volume will take 100% of remaining space."

  # Determine target device
  if [[ $LUKS -eq 1 ]]; then
    TARGET_DEV="/dev/mapper/${LUKS_NAME}"
  else
    block_list=($(lsblk -nrpo NAME,TYPE | awk '$2=="part"{print $1}'))
    PS3="$prompt1"
    echo -e "Select partition:"
    select OPT in "${block_list[@]}"; do
      if contains_element "$OPT" "${block_list[@]}"; then
        TARGET_DEV="$OPT"
        break
      else
        invalid_option
      fi
    done
  fi

  # Safety check
  if [[ -z "$TARGET_DEV" ]]; then
    print_error "No valid target device selected."
    return 1
  fi

  # Initialise LVM
  pvcreate "$TARGET_DEV"
  vgcreate "$VG_NAME" "$TARGET_DEV"

  # Ask only for root + extras
  read -p "Enter root volume size (e.g. 25G): " ROOT_SIZE
  lvcreate -L "${ROOT_SIZE}" "$VG_NAME" -n root

  echo
  print_info "Now you can add extra volumes such as home, var, swap..."
  read -p "How many extra volumes? [0-9]: " extra_count

  i=1
  while [[ $i -le $extra_count ]]; do
    read -p "Name for volume $i (e.g. home): " lvname
    if [[ $i -eq $extra_count ]]; then
      lvcreate -l 100%FREE "$VG_NAME" -n "$lvname"
    else
      read -p "Size for $lvname (e.g. 10G): " lvsize
      lvcreate -L "$lvsize" "$VG_NAME" -n "$lvname"
    fi
    i=$((i+1))
  done

  LVM=1
  export LVM VG_NAME
}

#}}}
#SELECT|FORMAT PARTITIONS {{{
format_partitions(){
  print_title "FILESYSTEMS - ${WIKI}/File_Systems"
  print_info "This step will select and format the selected partiton where the archlinux will be installed"
  print_danger "\tAll data on the ROOT and SWAP partition will be LOST."
  i=0

  block_list=(`lsblk | grep 'part\|lvm' | awk '{print substr($1,3)}'`)

  # check if there is no partition
  if [[ ${#block_list[@]} -eq 0 ]]; then
    echo "No partition found"
    exit 0
  fi

  partitions_list=()
  for OPT in ${block_list[@]}; do
    check_lvm=`echo $OPT | grep lvm`
    if [[ -z $check_lvm ]]; then
      partitions_list+=("/dev/$OPT")
    else
      partitions_list+=("/dev/mapper/$OPT")
    fi
  done

  # partitions based on boot system
  if [[ $UEFI -eq 1 ]]; then
    partition_name=("root" "EFI" "swap" "another")
  else
    partition_name=("root" "swap" "another")
  fi

  select_filesystem(){
    filesystems_list=( "btrfs" "ext2" "ext3" "ext4" "f2fs" "jfs" "nilfs2" "ntfs" "vfat" "xfs");
    PS3="$prompt1"
    echo -e "Select filesystem:\n"
    select filesystem in "${filesystems_list[@]}"; do
      if contains_element "${filesystem}" "${filesystems_list[@]}"; then
        break
      else
        invalid_option
      fi
    done
  }

  disable_partition(){
    #remove the selected partition from list
    unset partitions_list[${partition_number}]
    partitions_list=(${partitions_list[@]})
    #increase i
    [[ ${partition_name[i]} != another ]] && i=$(( i + 1 ))
  }

  format_partition(){
    read_input_text "Confirm format $1 partition"
    if [[ $OPTION == y ]]; then
      [[ -z $3 ]] && select_filesystem || filesystem=$3
      mkfs.${filesystem} $1 \
        $([[ ${filesystem} == xfs || ${filesystem} == btrfs ]] && echo "-f") \
        $([[ ${filesystem} == vfat ]] && echo "-F32") \
        $([[ $TRIM -eq 1 && ${filesystem} == ext4 ]] && echo "-E discard") \
        $([[ $TRIM -eq 1 && ${filesystem} == btrfs ]] && echo "-O discard")
      fsck $1
      mkdir -p $2
      mount -t ${filesystem} $1 $2
      disable_partition
    fi
  }

  format_swap_partition(){
    read_input_text "Confirm format $1 partition"
    if [[ $OPTION == y ]]; then
      mkswap $1
      swapon $1
      disable_partition
    fi
  }

  create_swap(){
    swap_options=("partition" "file" "skip");
    PS3="$prompt1"
    echo -e "Select ${BYellow}${partition_name[i]}${Reset} filesystem:\n"
    select OPT in "${swap_options[@]}"; do
      case "$REPLY" in
        1)
          select partition in "${partitions_list[@]}"; do
            #get the selected number - 1
            partition_number=$(( $REPLY - 1 ))
            if contains_element "${partition}" "${partitions_list[@]}"; then
              format_swap_partition "${partition}"
            fi
            break
          done
          break
          ;;
        2)
          total_memory=`grep MemTotal /proc/meminfo | awk '{print $2/1024}' | sed 's/\..*//'`
          fallocate -l ${total_memory}M ${MNT}/swapfile
          chmod 600 ${MNT}/swapfile
          mkswap ${MNT}/swapfile
          swapon ${MNT}/swapfile
          i=$(( i + 1 ))
          break
          ;;
        3)
          i=$(( i + 1 ))
          break
          ;;
        *)
          invalid_option
          ;;
      esac
    done
  }

  check_mountpoint(){
    if mount | grep $2; then
      echo "Successfully mounted"
      disable_partition "$1"
    else
      echo "WARNING: Not Successfully mounted"
    fi
  }

#SET EFI PARTITION {{{
set_efi_partition() {
  # Automatically mount EFI System Partition to /boot for UEFI installs
  if [[ $UEFI -eq 1 ]]; then
    EFI_MNT="/boot"
    print_info "UEFI mode detected — EFI partition will be mounted at ${EFI_MNT}"
  else
    EFI_MNT=""
    print_info "BIOS mode detected — no EFI mount required."
  fi
}
#}}}

  while true; do
    PS3="$prompt1"
    if [[ ${partition_name[i]} == swap ]]; then
      create_swap
    else
      echo -e "Select ${BYellow}${partition_name[i]}${Reset} partition:\n"
      select partition in "${partitions_list[@]}"; do
        #get the selected number - 1
        partition_number=$(( $REPLY - 1 ))
        if contains_element "${partition}" "${partitions_list[@]}"; then
          case ${partition_name[i]} in
            root)
             ROOT_PART="${partition}"     # ✅ keep full path (/dev/…)
             ROOT_MNT="${partition}"
             format_partition "${partition}" "${MNT}"
              ;;
            EFI)
              set_efi_partition
              read_input_text "Format ${partition} partition"
              if [[ $OPTION == y ]]; then
                format_partition "${partition}" "${MNT}${EFI_MNT}" vfat
              else
                mkdir -p "${MNT}${EFI_MNT}"
                mount -t vfat "${partition}" "${MNT}${EFI_MNT}"
                check_mountpoint "${partition}" "${MNT}${EFI_MNT}"
              fi
              ;;
            another)
              read -p "Mountpoint [ex: /home]:" directory
              [[ $directory == "/boot" ]] && BOOT_MNT=`echo ${partition} | sed 's/[0-9]//'`
              select_filesystem
              read_input_text "Format ${partition} partition"
              if [[ $OPTION == y ]]; then
                format_partition "${partition}" "${MNT}${directory}" "${filesystem}"
              else
                read_input_text "Confirm fs="${filesystem}" part="${partition}" dir="${directory}""
                if [[ $OPTION == y ]]; then
                  mkdir -p ${MNT}${directory}
                  mount -t ${filesystem} ${partition} ${MNT}${directory}
                  check_mountpoint "${partition}" "${MNT}${directory}"
                fi
              fi
              ;;
          esac
          break
        else
          invalid_option
        fi
      done
    fi
    #check if there is no partitions left
    if [[ ${#partitions_list[@]} -eq 0 && ${partition_name[i]} != swap ]]; then
      break
    elif [[ ${partition_name[i]} == another ]]; then
      read_input_text "Configure more partitions"
      [[ $OPTION != y ]] && break
    fi
  done
  pause_function
}

# Function: copy with progress bar
copy_progress() {
    local SRC_DIR="$1"
    local DEST_DIR="$2"
    
    [[ -d "$SRC_DIR" ]] || { echo "Error: Source '$SRC_DIR' missing"; return 1; }
    [[ -d "$DEST_DIR" ]] || { echo "Error: Destination '$DEST_DIR' missing"; return 1; }
    
    local TOTAL_SIZE=$(du -sb "$SRC_DIR" | awk '{print $1}')
    echo "Total size: $(numfmt --to=iec-i --suffix=B $TOTAL_SIZE)"
    echo
    
    if tar cf - -C "$SRC_DIR" . | pv -pterb -s "$TOTAL_SIZE" | tar xpf - -C "$DEST_DIR"; then
        echo -e "\n✅ Copy Complete!"
        return 0
    else
        echo -e "\n❌ Copy Failed!"
        return 1
    fi
}

#}}}
#INSTALL WAYBANG {{{
install_waybang(){
  print_title "INSTALL WAYBANG - www.archbang.org"
  print_info "Installing please wait..."

  # Check if running from live environment
  check_archiso

  # copy source to new install
  if ! copy_progress /run/archiso/airootfs/ "${MNT}/"; then
    error_msg "ERROR: Failed to copy system files"
  fi

  # Sync changes made during live session
  UPPERDIR=$(find /run/archiso/cowspace -type d -path "*/persistent_*/x86_64/upperdir" 2>/dev/null | head -1)
  if [[ -n "$UPPERDIR" && -d "$UPPERDIR" ]]; then
    print_info "Syncing live session changes..."
    rsync -av "$UPPERDIR/" "${MNT}/" >/dev/null 2>&1
  fi

  # Generate unique machine id
  arch-chroot ${MNT} systemd-machine-id-setup

  # Convert mkinitcpio preset from archiso to standard for installed system
  cat > ${MNT}/etc/mkinitcpio.d/linux.preset <<'EOF'
# SPDX-License-Identifier: GPL-3.0-or-later
# mkinitcpio preset file for the 'linux' package

PRESETS=('default' 'fallback')
ALL_kver='/boot/vmlinuz-linux'
ALL_config='/etc/mkinitcpio.conf'

default_image="/boot/initramfs-linux.img"
fallback_image="/boot/initramfs-linux-fallback.img"
fallback_options="-S autodetect"
EOF

  # put live driver into new install
  cp /etc/X11/xorg.conf.d/20-gpudriver.conf ${MNT}/etc/X11/xorg.conf.d/20-gpudriver.conf &>/dev/null

  # Remove abinstall from target device
  rm -f ${MNT}/home/${LIVE_USER}/AB_Scripts/abinstall &> /dev/null

  # Remove gparted-launcher script
  rm -f ${MNT}/home/${LIVE_USER}/AB_Scripts/gparted-launcher &> /dev/null

  # Remove installer from root-menu
  sed -i '/<!-- abinstall 5 -->/,+3d' ${MNT}/home/${LIVE_USER}/.config/labwc/menu.xml

  # Remove Gparted from root-menu (only the GParted item, not System)
  sed -i '/GParted/,+2d' ${MNT}/home/${LIVE_USER}/.config/labwc/menu.xml

  # remove autologin from install
  rm -r ${MNT}/etc/systemd/system/getty@tty1.service.d &>/dev/null

  # systemd journald configuration
  rm ${MNT}/etc/systemd/system/default.target &> /dev/null
  sed -i 's/volatile/auto/g' ${MNT}/etc/systemd/journald.conf.d/volatile-storage.conf
  mv ${MNT}/etc/systemd/journald.conf.d/volatile-storage.conf ${MNT}/etc/systemd/journald.conf.d/auto-storage.conf

  # remove pacman-init.service link
  unlink ${MNT}/etc/systemd/system/multi-user.target.wants/pacman-init.service &>/dev/null
  rm -f ${MNT}/etc/systemd/system/pacman-init.service

  rm -f ${MNT}/etc/systemd/system/etc-pacman.d-gnupg.mount

  # clean out live user overlay files from /etc/skel on new install
  rm -r ${MNT}/etc/skel &>/dev/null

  # Revert gparted to stock version without sudo
  #sed -i 's|^Exec=sudo /usr/bin/gparted|Exec=/usr/bin/gparted|' ${MNT}/usr/share/applications/gparted.desktop

  # Restore gparted visibility in menus
  sed -i '/^Hidden=true/d' ${MNT}/usr/share/applications/gparted.desktop

}
#}}}

#CONFIGURE FSTAB {{{
configure_fstab(){
  genfstab -U "$MNT" >> "${MNT}/etc/fstab" 
}
#}}}

#CONFIGURE HOSTNAME {{{
configure_hostname() {
  print_title "HOSTNAME - ${WIKI}/hostname"
  print_info "A host name identifies your machine on a network (max 63 chars)."

  if [[ $INTERACTIVE -eq 1 && -z "$host_name" ]]; then
    read -p "Hostname [ex: arch]: " host_name
  fi

  host_name="${host_name:-waybang}"

  print_info "Using hostname: ${host_name}"
  echo "${host_name}" > "${MNT}/etc/hostname"

  arch_chroot "cat > /etc/hosts <<EOF
127.0.0.1   localhost
::1         localhost
127.0.1.1   ${host_name}.localdomain ${host_name}
EOF"
}

#}}}
#CONFIGURE TIMEZONE {{{
configure_timezone(){
  print_title "TIMEZONE - ${WIKI}/Timezone"
  print_info "In an operating system the time (clock) is determined by four parts: Time value, Time standard, Time Zone, and DST (Daylight Saving Time if applicable)."
  OPTION=n
  while [[ $OPTION != y ]]; do
    settimezone
    read_input_text "Confirm timezone (${ZONE}/${SUBZONE})"
  done
  arch_chroot "ln -sf /usr/share/zoneinfo/${ZONE}/${SUBZONE} /etc/localtime"
}
#}}}
#CONFIGURE HARDWARECLOCK {{{
configure_hardwareclock(){
#  print_title "HARDWARE CLOCK - ${WIKI}/Hardware_Clock"
#  print_info "Setting hardware clock to UTC (default Arch convention)."

  # Always use UTC
  arch_chroot "hwclock --systohc --utc"

#  print_success "Hardware clock set to UTC."
}
#}}}
#CONFIGURE LOCALE {{{
configure_locale(){
  print_title "LOCALE - ${WIKI}/Locale"
  print_info "Locales are used in Linux to define which language the user uses & character sets."
  OPTION=n
  while [[ $OPTION != y ]]; do
    setlocale
    read_input_text "Confirm locale ($LOCALE)"
  done
  echo 'LANG="'$LOCALE_UTF8'"' > ${MNT}/etc/locale.conf
  arch_chroot "sed -i '/en_US\.UTF-8/ s/^#*/#/'  /etc/locale.gen"
  arch_chroot "sed -i '/'${LOCALE_UTF8}'/s/^#//' /etc/locale.gen"
  arch_chroot "locale-gen"
}
#}}}
#CONFIGURE MKINITCPIO {{{
configure_mkinitcpio(){
    print_title "Configuring mkinitcpio"
    print_info "Setting up initramfs hooks based on your system configuration."

    # Determine hooks based on setup (systemd-based modern configuration)
    if [[ $LUKS -eq 1 && $LVM -eq 1 ]]; then
        MKINITCPIO_HOOKS="base systemd autodetect microcode modconf kms keyboard keymap sd-vconsole sd-encrypt block lvm2 filesystems fsck"
    elif [[ $LUKS -eq 1 ]]; then
        MKINITCPIO_HOOKS="base systemd autodetect microcode modconf kms keyboard keymap sd-vconsole sd-encrypt block filesystems fsck"
    elif [[ $LVM -eq 1 ]]; then
        MKINITCPIO_HOOKS="base systemd autodetect microcode modconf kms keyboard keymap sd-vconsole block lvm2 filesystems fsck"
    else
        MKINITCPIO_HOOKS="base systemd autodetect microcode modconf kms keyboard keymap sd-vconsole block filesystems fsck"
    fi

    # Update mkinitcpio.conf with hooks
    arch_chroot "sed -i -E 's|^HOOKS=.*|HOOKS=(${MKINITCPIO_HOOKS})|' /etc/mkinitcpio.conf"

    # Comment out xz compression and compression options to use zstd default for installed system
    arch_chroot "sed -i 's/^COMPRESSION=\"xz\"/#COMPRESSION=\"xz\"/' /etc/mkinitcpio.conf"
    arch_chroot "sed -i 's/^COMPRESSION_OPTIONS=/#COMPRESSION_OPTIONS=/' /etc/mkinitcpio.conf"

    # Rebuild initramfs
    arch_chroot "mkinitcpio -p linux"

    print_info "Initramfs configuration complete."
    pause_function
}

#CONFIGURE BOOTLOADER {{{
# {{{ CONFIGURE BOOTLOADER
# # {{{ CONFIGURE BOOTLOADER
configure_bootloader(){
  print_title "GRUB2 configuration"
  print_info "Installing GRUB bootloader with support for LUKS, LVM, and microcode."

  # --- Detect system mode (UEFI or BIOS) ---
  if [[ -d /sys/firmware/efi ]]; then
      UEFI=1
      print_info "UEFI mode detected"
  else
      UEFI=0
      print_info "BIOS (legacy) mode detected"
  fi

  # --- Verify EFI partition is mounted if UEFI ---
  if [[ $UEFI -eq 1 ]]; then
      if ! mount | grep -q "${MNT}/boot"; then
          print_error "EFI partition is not mounted at ${MNT}/boot!"
          lsblk -f
          return 1
      fi
  fi

  # --- Detect root partition automatically ---
  if [[ -z "$ROOT_PART" || ! -b "$ROOT_PART" ]]; then
      ROOT_PART=$(lsblk -no PATH,MOUNTPOINT | grep " ${MNT}$" | awk '{print $1}')
      print_info "Detected root partition: ${ROOT_PART}"
  fi

  if [[ -z "$ROOT_PART" || ! -b "$ROOT_PART" ]]; then
      print_error "Unable to determine root partition for GRUB setup!"
      lsblk -f
      return 1
  fi

  # --- Handle LUKS UUID detection if used ---
  if [[ $LUKS -eq 1 ]]; then
      if [[ -n "$LUKS_PART" ]]; then
          LUKS_UUID=$(blkid -s UUID -o value "$LUKS_PART")
      elif [[ -n "$LUKS_DISK" ]]; then
          LUKS_UUID=$(blkid -s UUID -o value "/dev/${LUKS_DISK}")
      fi
      print_info "Detected LUKS UUID: $LUKS_UUID"
  fi

  # --- Install GRUB ---
  if [[ $UEFI -eq 1 ]]; then
      print_info "Installing GRUB (UEFI mode) to /boot/EFI/GRUB/"
      arch_chroot "grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB --recheck"

  else
      print_info "Installing GRUB (BIOS mode)"

      # --- Ensure correct device for BIOS installs ---
      # BIOS GRUB must install to the entire disk (e.g. /dev/vda), not a partition (e.g. /dev/vda1)
      if [[ -z "$BOOT_DEV" || "$BOOT_DEV" =~ [0-9]$ ]]; then
          BOOT_DEV=$(lsblk -no pkname "$ROOT_PART" | awk '{print "/dev/"$1}')
          print_info "Corrected BOOT_DEV to ${BOOT_DEV} (parent of ${ROOT_PART})"
      fi

      # Validate disk exists
      if [[ -z "$BOOT_DEV" || ! -b "$BOOT_DEV" ]]; then
          print_error "Could not determine valid boot device for BIOS install!"
          lsblk -f
          return 1
      fi

      # --- Run grub-install outside chroot (BIOS) ---
      grub-install --target=i386-pc --boot-directory=${MNT}/boot ${BOOT_DEV}
      if [[ $? -ne 0 ]]; then
          print_error "GRUB installation failed for BIOS mode!"
          lsblk -f
          return 1
      fi
      print_success "GRUB successfully installed to ${BOOT_DEV}"
  fi

  # --- Build kernel parameters ---
  if [[ $LUKS -eq 1 && $LVM -eq 1 ]]; then
      ROOT_LV="${VG_NAME}-${LV_ROOT}"
      CMDLINE="cryptdevice=UUID=${LUKS_UUID}:${LUKS_NAME} root=/dev/mapper/${ROOT_LV} rw"
  elif [[ $LUKS -eq 1 ]]; then
      CMDLINE="cryptdevice=UUID=${LUKS_UUID}:${LUKS_NAME} root=/dev/mapper/${LUKS_NAME} rw"
  elif [[ $LVM -eq 1 ]]; then
      ROOT_LV="${VG_NAME}-${LV_ROOT}"
      CMDLINE="root=/dev/mapper/${ROOT_LV} rw"
  else
      partuuid=$(blkid -s PARTUUID -o value "$ROOT_PART")
      if [[ -z "$partuuid" ]]; then
          uuid=$(blkid -s UUID -o value "$ROOT_PART")
          CMDLINE="root=UUID=${uuid} rw"
          print_warning "PARTUUID not found; using filesystem UUID instead."
      else
          CMDLINE="root=PARTUUID=${partuuid} rw"
      fi
  fi

  # --- Update /etc/default/grub inside chroot ---
  arch_chroot "sed -i.bak -E 's|^GRUB_CMDLINE_LINUX=.*|GRUB_CMDLINE_LINUX=\"${CMDLINE}\"|' /etc/default/grub"

  # --- Enable GRUB cryptodisk if using LUKS ---
  if [[ $LUKS -eq 1 ]]; then
      arch_chroot "grep -q '^GRUB_ENABLE_CRYPTODISK' /etc/default/grub \
          && sed -i 's/^#GRUB_ENABLE_CRYPTODISK=.*/GRUB_ENABLE_CRYPTODISK=y/' /etc/default/grub \
          || echo 'GRUB_ENABLE_CRYPTODISK=y' >> /etc/default/grub"
  fi

  # --- Generate GRUB configuration ---
  arch_chroot "grub-mkconfig -o /boot/grub/grub.cfg"

  print_success "GRUB2 installation and configuration complete."
  pause_function
}
# }}}

# }}}

#ROOT PASSWORD {{{
root_password(){
  print_title "ROOT PASSWORD"
  print_warning "Enter your new root password"
  arch_chroot "passwd"
  pause_function
}

# SETUP NEW USER {{{
setup_user(){
  print_title "CREATE NEW USER"
  echo
  
  # Check if mvuser script exists, if not create inline user setup
  if [[ -f ${MNT}/root/mvuser ]]; then
    arch_chroot "/root/mvuser"
    arch_chroot "rm -f /root/mvuser"
  else
    # Inline user creation if mvuser doesn't exist
    print_info "Creating new user account..."
    
    read -p "Enter username: " new_username
    
    arch_chroot "useradd -m -G wheel,storage,power,audio,video -s /bin/bash ${new_username}"
    
    print_info "Set password for ${new_username}"
    arch_chroot "passwd ${new_username}"
    
    # Enable sudo for wheel group
    arch_chroot "sed -i 's/^# %wheel ALL=(ALL:ALL) ALL/%wheel ALL=(ALL:ALL) ALL/' /etc/sudoers"
    
    # Remove or rename live user if exists
    if [[ -d ${MNT}/home/${LIVE_USER} ]]; then
      read_input_text "Remove live user (${LIVE_USER}) home directory"
      if [[ $OPTION == y ]]; then
        arch_chroot "userdel -r ${LIVE_USER} 2>/dev/null || true"
      fi
    fi
  fi
  
  pause_function
}

#}}}
#FINISH {{{
finish(){
  print_title "WAYBANG INSTALL COMPLETED..."
  read_input_text "Reboot system"
  if [[ $OPTION == y ]]; then
    umount_partitions
    reboot
  fi
  exit 0
}
#}}}

# Trap errors and cleanup
trap 'echo "Error occurred. Cleaning up..."; umount_partitions 2>/dev/null; exit 1' ERR

check_root
check_boot_system
detect_cpu
check_trim

while true
do
  print_title "WayBang installer - www.archbang.org"
  echo " 1) $(mainmenu_item "${checklist[1]}" "Partition Scheme")"
  echo " 2) $(mainmenu_item "${checklist[2]}" "Install WayBang")"
  echo " 3) $(mainmenu_item "${checklist[3]}" "Hostname")"
  echo " 4) $(mainmenu_item "${checklist[4]}" "Location")"
  echo " 5) $(mainmenu_item "${checklist[5]}" "Locale")"
  echo " 6) $(mainmenu_item "${checklist[6]}" "Desktop Keyboard Layout")"
  echo " 7) $(mainmenu_item "${checklist[7]}" "Bootloader")"
  echo " 8) $(mainmenu_item "${checklist[8]}" "Root and USer Setup")"
  echo ""
  echo " d) Done"
  echo ""
  read_input_options
  for OPT in ${OPTIONS[@]}; do
    case "$OPT" in
      1)
        umount_partitions
        create_partition_scheme
        format_partitions
        checklist[1]=1
        ;;
      2)
        install_waybang
        configure_fstab
        configure_mkinitcpio
        checklist[2]=1
        ;;
      3)
        configure_hostname
        checklist[3]=1
        ;;
      4)
        configure_timezone
        configure_hardwareclock
        configure_mirrors
        checklist[4]=1
        ;;
      5)
        configure_locale
        checklist[5]=1
        ;;
      6)
        select_xkeymap
        checklist[6]=1
        ;;
      7)
        configure_bootloader
        checklist[7]=1
        ;;
      8)
        root_password
        setup_user
        checklist[8]=1
        ;;
      "d")
        finish
        ;;
      *)
        invalid_option
        ;;
    esac
  done
done
#}}}
